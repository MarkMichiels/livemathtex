---
phase: 09-structural-math-parsing
plan: 01
type: execute
---

<objective>
Parse calculations within math blocks into structured representation with character-level spans.

Purpose: Replace regex-based operator detection in `Lexer.extract_calculations()` with span-aware parsing built on Phase 8's hybrid parser.
Output: New `parser/calculation_parser.py` module with `ParsedCalculation` dataclass containing operator spans, lhs/rhs spans, and result spans.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-markdown-parser-integration/08-01-SUMMARY.md

**Key files:**
@src/livemathtex/parser/markdown_parser.py
@src/livemathtex/parser/lexer.py (extract_calculations method - to be replaced)
@src/livemathtex/parser/models.py (Calculation dataclass)

**Phase 8 deliverables:**
- `ParsedMathBlock` with `doc_start_offset`, `doc_end_offset`, `inner_content`
- `latex_nodes` from pylatexenc with character positions
- `extract_math_blocks()` function

**Operators to parse:**
- `===` - Unit definition (e.g., `kWh === 3600000 \cdot J`)
- `:=` - Assignment (e.g., `x := 5`)
- `==` - Evaluation (e.g., `x + y == 15`)
- `=>` - Symbolic (e.g., `\frac{a}{b} => simplified`)
- `:=_==` - Combined assignment + evaluation (e.g., `x := 5 == 5`)

**Constraints:**
- Build on Phase 8's `ParsedMathBlock` - don't duplicate parsing
- Character spans must be relative to document, not just math block
- Support multiline math blocks (one calculation per line)
- Handle inline unit hints `[unit]` at end of results
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ParsedCalculation dataclass with spans</name>
  <files>src/livemathtex/parser/calculation_parser.py</files>
  <action>
Create new module `parser/calculation_parser.py` with span-aware dataclasses:

```python
@dataclass
class Span:
    """Character span in document."""
    start: int  # Start offset in document
    end: int    # End offset in document (exclusive)

    def extract(self, text: str) -> str:
        """Extract the span from document text."""
        return text[self.start:self.end]

@dataclass
class ParsedCalculation:
    """Calculation with character-level spans."""
    operation: str          # "===", ":=", "==", "=>", ":=_==", "value", "ERROR"
    operator_span: Span     # Position of operator in document

    # LHS (left-hand side) - variable name for assignments
    lhs: Optional[str] = None
    lhs_span: Optional[Span] = None

    # RHS (right-hand side) - expression
    rhs: Optional[str] = None
    rhs_span: Optional[Span] = None

    # Result (after == for evaluations)
    result: Optional[str] = None
    result_span: Optional[Span] = None

    # Unit hint (from [unit] or HTML comment)
    unit_hint: Optional[str] = None
    unit_hint_span: Optional[Span] = None

    # Original line for reference
    line: str = ""
    line_span: Optional[Span] = None

    # Error info
    error_message: Optional[str] = None
```

Key design decisions:
- All spans are document-relative (not math-block-relative)
- `Span.extract(text)` allows easy content retrieval
- Separate spans for each semantic part (lhs, rhs, result, unit_hint)
  </action>
  <verify>python -c "from livemathtex.parser.calculation_parser import ParsedCalculation, Span; print('OK')"</verify>
  <done>ParsedCalculation and Span dataclasses importable</done>
</task>

<task type="auto">
  <name>Task 2: Implement parse_calculation function</name>
  <files>src/livemathtex/parser/calculation_parser.py</files>
  <action>
Add function to parse a single line into ParsedCalculation:

```python
def parse_calculation_line(
    line: str,
    line_start_offset: int,
    unit_comment: Optional[str] = None
) -> Optional[ParsedCalculation]:
    """Parse a single line of LaTeX into a ParsedCalculation.

    Args:
        line: Single line of LaTeX (stripped)
        line_start_offset: Character offset of line start in document
        unit_comment: Unit hint from HTML comment (if any)

    Returns:
        ParsedCalculation or None if line has no operators
    """
```

Implementation approach:
1. Check for operator presence (===, :=, ==, =>)
2. If no operators, return None (pure display LaTeX)
3. Check for bare '=' error first
4. Find operator with `str.find()` to get exact position
5. Split into lhs/rhs based on operator position
6. For `:=_==`, handle secondary `==` split
7. Check for inline unit hint `[unit]` at end of rhs/result
8. Calculate all spans using `line_start_offset`

Operator priority (must check in this order):
1. `===` (unit definition)
2. `:=` followed by `==` (combined assignment+eval)
3. `:=` (assignment)
4. `==` (evaluation)
5. `=>` (symbolic)
  </action>
  <verify>
python -c "
from livemathtex.parser.calculation_parser import parse_calculation_line
# Test assignment
calc = parse_calculation_line('x := 5', 10)
assert calc.operation == ':='
assert calc.lhs == 'x'
assert calc.rhs == '5'
assert calc.operator_span.start == 12  # 10 + 2 (after 'x ')
print('OK')
"
  </verify>
  <done>parse_calculation_line correctly parses operators with spans</done>
</task>

<task type="auto">
  <name>Task 3: Implement parse_math_block_calculations</name>
  <files>src/livemathtex/parser/calculation_parser.py</files>
  <action>
Add function to parse all calculations from a ParsedMathBlock:

```python
def parse_math_block_calculations(
    block: ParsedMathBlock,
    unit_comment: Optional[str] = None,
    value_comment: Optional[str] = None
) -> List[ParsedCalculation]:
    """Parse calculations from a math block.

    Args:
        block: ParsedMathBlock from Phase 8 parser
        unit_comment: Unit hint from HTML comment
        value_comment: Value lookup syntax from HTML comment

    Returns:
        List of ParsedCalculation objects
    """
```

Implementation:
1. Handle `value_comment` case first (special value lookup)
2. Split `block.inner_content` by newlines
3. Calculate line offsets within block (accounting for delimiter)
4. For each non-empty line, call `parse_calculation_line()`
5. Collect and return all ParsedCalculation objects

Line offset calculation:
- `line_doc_offset = block.doc_start_offset + delimiter_len + cumulative_offset`
- Where `delimiter_len` is 2 for `$$`, 1 for `$`
- And `cumulative_offset` accounts for previous lines + newlines
  </action>
  <verify>
python -c "
from livemathtex.parser.markdown_parser import extract_math_blocks
from livemathtex.parser.calculation_parser import parse_math_block_calculations

text = '''# Test
\$\$
x := 5
y := x + 3 == 8
\$\$
'''
blocks = extract_math_blocks(text)
calcs = parse_math_block_calculations(blocks[0])
print(f'Found {len(calcs)} calculations')
assert len(calcs) == 2
assert calcs[0].operation == ':='
assert calcs[1].operation == ':=_=='
print('OK')
"
  </verify>
  <done>parse_math_block_calculations extracts all calculations from block</done>
</task>

<task type="auto">
  <name>Task 4: Add comprehensive tests for calculation parser</name>
  <files>tests/test_calculation_parser.py</files>
  <action>
Create comprehensive test suite:

**1. Span tests:**
- Span.extract() returns correct substring
- Operator spans point to exact operator position
- LHS/RHS spans correctly delimit content

**2. Operator parsing tests:**
- `===` unit definition
- `:=` simple assignment
- `==` evaluation
- `=>` symbolic
- `:=_==` combined assignment+eval

**3. Position accuracy tests:**
- `text[span.start:span.end]` matches expected content
- Multiline blocks have correct per-line offsets
- Inline math vs display math offsets correct

**4. Unit hint tests:**
- Inline `[unit]` extracted with span
- HTML comment unit passed through
- Unit hint span is accurate

**5. Edge cases:**
- Empty lines skipped
- Bare `=` creates ERROR calculation
- Lines without operators return None
- Whitespace handling around operators

**6. Integration tests:**
- Full document with multiple blocks
- Mix of calculations and pure display LaTeX
  </action>
  <verify>cd /home/mark/Repositories/livemathtex && python -m pytest tests/test_calculation_parser.py -v</verify>
  <done>All tests pass, span accuracy verified</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `from livemathtex.parser.calculation_parser import ...` works
- [ ] `parse_calculation_line()` returns correct spans for all operators
- [ ] `parse_math_block_calculations()` handles multiline blocks
- [ ] `text[span.start:span.end]` equals expected content for all spans
- [ ] Unit hints extracted correctly (both inline and comment)
- [ ] All tests pass
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Span positions are accurate (verified by content extraction)
- All 5 operator types parsed correctly
- Multiline blocks handled with correct line offsets
- Ready for Phase 10 to use spans for clear_text() refactor
</success_criteria>

<output>
After completion, create `.planning/phases/09-structural-math-parsing/09-01-SUMMARY.md`
</output>
