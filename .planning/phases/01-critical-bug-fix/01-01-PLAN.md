---
phase: 01-critical-bug-fix
plan: 01
type: tdd
---

<objective>
Fix ISSUE-003: Failed variable definition must not silently fall back to unit interpretation.

Purpose: Prevent silent calculation corruption by enforcing strict separation between value definitions and formula definitions.
Output: Working fix with tests, example error scenarios, and updated documentation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@docs/BACKLOG.md (ISSUE-003 section)
@src/livemathtex/engine/evaluator.py
@src/livemathtex/engine/pint_backend.py
@tests/test_pint_backend.py
@tests/conftest.py
@examples/README.md

**Root Cause Analysis:**

The `:=` operator handles two fundamentally different things:

1. **Value definition**: `V := 37824\ m^3` → number + optional unit (constant)
2. **Formula definition**: `Cap := V_{tot} * 15` → expression with variables

The code already has `_is_value_definition()` (line 347) that classifies these, but it's only used for IR tracking (`is_formula_flag`), not for validation.

**The problem:**
In `_compute()` (line ~1890), when resolving symbols:
- If symbol not in symbol table → check if it's a Pint unit
- If it IS a unit → silently substitute it (unless `is_pure_formula=True`, which only triggers when NO numbers present)
- Result: undefined `V` in `Cap := V * 15` becomes 1 volt

**Key Insight:**

Value definitions and formula definitions have mutually exclusive content rules:

| Type | Contains | Never Contains |
|------|----------|----------------|
| Value | Number, optional unit suffix | Variables, operators |
| Formula | Variables, numbers, operators | Standalone unit symbols |

If we classify first, then validate strictly, the bug cannot occur.

**Solution:**

Use existing `_is_value_definition()` classification to enforce strict rules:
- **Value definition**: Parse as number + unit. No symbol resolution needed.
- **Formula definition**: All symbols MUST be defined variables. Never fall back to unit interpretation.

The key change is in `_compute()`: remove the unit fallback path entirely for formula contexts. If a symbol isn't defined, it's an error - period.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write failing tests (RED phase)</name>
  <files>tests/test_definition_types.py</files>
  <action>
    Create new test file with explicit error scenario tests:

    1. Test undefined symbol in formula raises error (not unit fallback):
       - `Cap := V * 15` where V undefined → must error
       - Currently: silently interprets V as volt (WRONG)

    2. Test defined symbol in formula works:
       - Define `V_{tot} := 100`, then `Cap := V_{tot} * 15` → works

    3. Test value definitions still work:
       - `x := 5\ V` → works (volt as unit suffix)
       - `x := 5\ m/s` → works

    4. Test unit-conflict error on definition:
       - `V := 37824` → error (conflicts with volt)
       - `V_{tot} := 37824` → works (subscript disambiguates)

    Use `process_text()` from `livemathtex.core` and check for error markers in output.
  </action>
  <verify>pytest tests/test_definition_types.py -v shows tests FAILING (red phase)</verify>
  <done>Test file exists with 4+ test cases that currently fail due to the bug</done>
</task>

<task type="auto">
  <name>Task 2: Implement fix (GREEN phase)</name>
  <files>src/livemathtex/engine/evaluator.py</files>
  <action>
    In `_compute()` around line 1895-1910, remove the unit fallback:

    Current:
    ```python
    if is_pure_formula and is_unit:
        raise EvaluationError(...)
    elif is_unit:
        # silently use unit - THIS IS THE BUG
        sympy_unit = pint_to_sympy_with_prefix(clean_name)
        ...
    ```

    New:
    ```python
    if is_unit:
        # Undefined symbol matches unit name - always an error
        # Units belong as suffixes to numbers (5\ V), not standalone symbols
        unit_desc = self._get_unit_description(clean_name)
        raise EvaluationError(
            f"Undefined variable '{clean_name}'. "
            f"(Note: '{clean_name}' is also a unit ({unit_desc}). "
            f"Units must be attached to numbers like '5\\ {clean_name}', "
            f"not used as standalone symbols in formulas.)"
        )
    ```

    Remove the `is_pure_formula` condition - we NEVER fall back to unit interpretation.
  </action>
  <verify>pytest tests/test_definition_types.py -v shows all tests PASSING</verify>
  <done>All new tests pass, fix implemented</done>
</task>

<task type="auto">
  <name>Task 3: Verify no regressions</name>
  <files>tests/</files>
  <action>
    Run full test suite to ensure no existing functionality is broken.
    If any tests fail, analyze whether they relied on the buggy behavior and update them.
  </action>
  <verify>pytest tests/ -v shows 102+ tests passing</verify>
  <done>All existing tests pass (or are updated if they relied on buggy behavior)</done>
</task>

<task type="auto">
  <name>Task 4: Create exhaustive error catalog example</name>
  <files>examples/error-handling/input.md, examples/error-handling/output.md, examples/error-handling/.livemathtex.toml</files>
  <action>
    Create `examples/error-handling/` as exhaustive error catalog - every error the code can produce, documented and demonstrated.

    1. Create `.livemathtex.toml`:
       ```toml
       output = "output.md"
       ```

    2. Create `input.md` with ALL error categories:

       **Category 1: Variable Name Conflicts**
       - `V := 37824` → "conflicts with unit 'volt'"
       - `m := 10` → "conflicts with unit 'meter'"
       - `s := 5` → "conflicts with unit 'second'"
       - Correct: `V_{tot} := 37824`, `mass := 10`

       **Category 2: Undefined Variables**
       - `y := x * 2` where x undefined → "Undefined variable 'x'"
       - `Cap := V * 15` where V undefined → "Undefined variable 'V'" (NEW - was silent bug)
       - Correct: define variables first

       **Category 3: Undefined Variables in Evaluation**
       - `x ==` where x undefined → "Undefined variable: x"
       - Correct: define x first

       **Category 4: Unrecognized Units**
       - `x := 5\ foo` → "Unrecognized unit: 'foo'"
       - `x ==` `<!-- [bar] -->` where bar not defined → "Unrecognized unit in comment"
       - Correct: use standard units or define with ===

       **Category 5: Unit Definition Errors**
       - `=== kg` (no name) → "Unit definition requires a unit name"
       - `badunit === ???` (invalid def) → "Failed to define unit"

       **Category 6: LaTeX Parse Errors**
       - `x := \invalid{syntax}` → "Failed to parse LaTeX"

       **Category 7: Correct Usage (for comparison)**
       - Show correct alternatives for each error category

    3. Process to generate `output.md` with all error messages visible

    This serves as:
    - User documentation (what errors mean, how to fix)
    - Regression test (snapshot catches message changes)
    - Completeness check (forces thinking about all error paths)
  </action>
  <verify>livemathtex process examples/error-handling/input.md succeeds, output.md shows all error categories</verify>
  <done>examples/error-handling/ exists with comprehensive error catalog</done>
</task>

<task type="auto">
  <name>Task 5: Update documentation</name>
  <files>docs/BACKLOG.md, examples/README.md</files>
  <action>
    1. Update BACKLOG.md ISSUE-003:
       - Change status from "Open" to "Resolved"
       - Add resolution date
       - Document the solution (strict value/formula separation)
       - Note the breaking change (undefined symbols no longer fall back to units)

    2. Update examples/README.md:
       - Add `error-handling/` to the examples table
       - Expand "Reserved Names" section to explain value vs formula definitions
  </action>
  <verify>grep "Resolved" docs/BACKLOG.md shows ISSUE-003 marked resolved</verify>
  <done>BACKLOG.md updated, examples/README.md updated</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] pytest tests/test_definition_types.py -v passes
- [ ] pytest tests/ -v shows 102+ tests passing
- [ ] examples/error-handling/ exists with exhaustive error catalog (7 categories)
- [ ] All error types from codebase are demonstrated in examples/error-handling/
- [ ] docs/BACKLOG.md shows ISSUE-003 as resolved
</verification>

<success_criteria>

- TDD cycle complete (RED → GREEN)
- All 102+ existing tests still pass
- New error-handling examples demonstrate expected behavior
- Documentation updated (BACKLOG.md, examples/README.md)
- Atomic commits for each logical change
  </success_criteria>

<output>
After completion, create `.planning/phases/01-critical-bug-fix/01-01-SUMMARY.md`:

# Phase 1 Plan 1: ISSUE-003 Fix Summary

**[Substantive one-liner describing what shipped]**

## TDD Cycle

### RED
- Test file: tests/test_definition_types.py
- Test cases: [list]
- Why they failed: [explanation]

### GREEN
- Implementation in: src/livemathtex/engine/evaluator.py
- Changes: [description]

### REFACTOR
- [If any cleanup needed]

## Commits
- `test(01-01): add tests for undefined symbol handling`
- `feat(01-01): remove unit fallback for undefined symbols`
- `docs(01-01): add error-handling examples and update BACKLOG`

## Files Modified
- `src/livemathtex/engine/evaluator.py` - Remove unit fallback in _compute()
- `tests/test_definition_types.py` - New test file for definition types
- `examples/error-handling/` - New example directory with error scenarios
- `docs/BACKLOG.md` - Mark ISSUE-003 as resolved
- `examples/README.md` - Document error-handling examples

## Next Step
Phase 1 complete, ready for Phase 2
</output>
