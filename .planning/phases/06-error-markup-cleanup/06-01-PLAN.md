---
phase: 06-error-markup-cleanup
type: execute
---

<objective>
Fix ISS-016: Error markup in input document not detected or cleaned

Purpose: Make process_text() consistent with process_file() by auto-cleaning error markup, and provide detection capability for warning users.
Output: process_text() auto-cleans error markup; detect_error_markup() function available for inspection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/ISSUES.md (ISS-016 section)

**Key files:**
@src/livemathtex/core.py - contains process_text(), process_file(), clear_text()

**Root cause (from investigation):**
- `process_file()` (line 206-210) has pre-processing that auto-cleans error markup before parsing
- `process_text()` LACKS this pre-processing - goes straight to parsing
- Result: Error markup from previous runs persists and causes confusing behavior

**Prior fix pattern:**
```python
# From process_file() lines 206-210:
if '\\color{red}' in content or 'livemathtex-meta' in content:
    content, _ = clear_text(content)
```

**Prior decisions:**
- 01-01: Use nested brace regex for error markup matching
- 01-01: Pre-processing approach - clear already-processed content before parsing
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pre-processing to process_text()</name>
  <files>src/livemathtex/core.py</files>
  <action>
Add the same pre-processing logic from `process_file()` to `process_text()`:

1. After the docstring, before parsing, add:
```python
# Pre-process: If content appears to be already processed
# (contains error markup or livemathtex-meta), clear it first.
# This ensures idempotent processing of output files.
if '\\color{red}' in content or 'livemathtex-meta' in content:
    content, _ = clear_text(content)
```

2. Add this BEFORE the `lexer = Lexer()` line (around line 409)

This makes process_text() behavior consistent with process_file().
  </action>
  <verify>pytest tests/test_process_clear_cycle.py -v passes</verify>
  <done>process_text() auto-cleans error markup before parsing</done>
</task>

<task type="auto">
  <name>Task 2: Add detect_error_markup() function</name>
  <files>src/livemathtex/core.py, src/livemathtex/__init__.py</files>
  <action>
Add a new function to detect existing error markup in content:

```python
def detect_error_markup(content: str) -> dict:
    """
    Detect existing error markup in content from previous processing.

    Args:
        content: Markdown content to check

    Returns:
        Dict with:
        - has_errors: bool - True if error markup found
        - count: int - Number of error patterns found
        - has_meta: bool - True if livemathtex-meta comment found
        - patterns: list[str] - Types of error patterns found
    """
    result = {
        'has_errors': False,
        'count': 0,
        'has_meta': False,
        'patterns': []
    }

    # Check for error color markup
    error_matches = re.findall(r'\\color\{red\}', content)
    if error_matches:
        result['has_errors'] = True
        result['count'] = len(error_matches)
        result['patterns'].append('color{red}')

    # Check for inline error text
    inline_errors = re.findall(r'\\text\{\(Error:', content)
    if inline_errors:
        result['has_errors'] = True
        result['count'] += len(inline_errors)
        result['patterns'].append('text{Error}')

    # Check for livemathtex metadata
    if 'livemathtex-meta' in content:
        result['has_meta'] = True
        result['patterns'].append('livemathtex-meta')

    return result
```

Add the function after `clear_text()` and before `process_file()`.
Export it in `__init__.py` alongside other public APIs.
  </action>
  <verify>python -c "from livemathtex import detect_error_markup; print(detect_error_markup('test \\\\color{red}{error}'))"</verify>
  <done>detect_error_markup() function available and exported</done>
</task>

<task type="auto">
  <name>Task 3: Add tests for error markup handling</name>
  <files>tests/test_error_markup.py</files>
  <action>
Create new test file `tests/test_error_markup.py` with:

```python
"""Tests for error markup detection and cleanup (ISS-016)."""

import pytest
from livemathtex import process_text, detect_error_markup


class TestDetectErrorMarkup:
    """Test error markup detection function."""

    def test_no_errors(self):
        """Clean content should return no errors."""
        content = '$E := 100\\ J$'
        result = detect_error_markup(content)
        assert result['has_errors'] is False
        assert result['count'] == 0
        assert result['has_meta'] is False

    def test_detect_color_red(self):
        """Should detect \\color{red} error markup."""
        content = '$E == \\color{red}{\\text{Error: undefined}}$'
        result = detect_error_markup(content)
        assert result['has_errors'] is True
        assert result['count'] >= 1
        assert 'color{red}' in result['patterns']

    def test_detect_inline_error(self):
        """Should detect inline Error: text."""
        content = '$E == \\text{(Error: something)}$'
        result = detect_error_markup(content)
        assert result['has_errors'] is True
        assert 'text{Error}' in result['patterns']

    def test_detect_meta(self):
        """Should detect livemathtex-meta comment."""
        content = '> *livemathtex: info* <!-- livemathtex-meta -->'
        result = detect_error_markup(content)
        assert result['has_meta'] is True
        assert 'livemathtex-meta' in result['patterns']


class TestProcessTextAutoClean:
    """Test that process_text() auto-cleans error markup."""

    def test_auto_cleans_error_markup(self):
        """process_text() should auto-clean existing error markup."""
        # Content with error markup from previous run
        content = '''$E := 100\\ J$
$E ==
\\\\ \\color{red}{\\text{Error: something}}$'''

        result, _ = process_text(content)

        # Should NOT contain original error
        assert '\\color{red}' not in result
        # Should have new evaluation (100 J)
        assert '100' in result

    def test_auto_cleans_meta(self):
        """process_text() should remove livemathtex-meta before processing."""
        content = '''$E := 100\\ J$

---

> *livemathtex: 2026-01-12 | 1 definition | no errors | 0.01s* <!-- livemathtex-meta -->
'''
        result, _ = process_text(content)

        # Should have exactly one meta block (the new one)
        assert result.count('livemathtex-meta') == 1

    def test_reprocess_with_errors_produces_clean_output(self):
        """Re-processing output with errors should produce clean new output."""
        # First process - will have error due to undefined var
        content = '$x ==$ <!-- undefined -->'
        result1, _ = process_text(content)

        # Result1 likely has error markup
        # Re-processing should auto-clean and produce same result
        result2, _ = process_text(result1)

        # Both should have consistent structure
        assert result1.count('$x ==') == result2.count('$x ==')
```

Run tests to verify all pass.
  </action>
  <verify>pytest tests/test_error_markup.py -v shows all tests passing</verify>
  <done>6 tests for error markup detection and auto-cleanup pass</done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `pytest tests/test_error_markup.py -v` - All 6 new tests pass
- [ ] `pytest tests/ -v` - Full suite passes (202+ tests)
- [ ] `process_text()` has pre-processing logic matching `process_file()`
- [ ] `detect_error_markup()` exported in `__init__.py`
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- ISS-016 resolved: error markup detection and auto-cleanup works
- No regressions in existing functionality
</success_criteria>

<output>
After completion, create `.planning/phases/06-error-markup-cleanup/06-01-SUMMARY.md`
</output>
