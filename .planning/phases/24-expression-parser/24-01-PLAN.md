# Phase 24 Plan 01: Expression Parser

<objective>
Build a recursive descent parser that converts tokens from ExpressionTokenizer into an expression tree. The tree structure enables direct Pint evaluation without SymPy.
</objective>

<execution_context>
@src/livemathtex/parser/expression_tokenizer.py - Token types and tokenizer (Phase 23)
@.planning/phases/23-remove-latex2sympy/23-RESEARCH.md - Architecture patterns and AST design
@tests/test_expression_tokenizer.py - Test patterns to follow
</execution_context>

<context>
## Background

Phase 23 created the tokenizer that produces typed tokens (NUMBER, VARIABLE, UNIT, OPERATOR, FRAC, LPAREN, RPAREN, LBRACE, RBRACE, EOF). Now we need a parser that builds an expression tree from these tokens.

## Key Requirements

1. **Operator precedence (PEMDAS):**
   - Parentheses (highest)
   - Exponentiation (^) - right associative
   - Multiplication/Division (* / \cdot \times)
   - Addition/Subtraction (+ -)

2. **Fraction handling:**
   - `\frac{a}{b}` → Division node (a / b)
   - Nested fractions supported

3. **Unary operators:**
   - Negative numbers: `-5`
   - Negative expressions: `-(a + b)`

4. **No implicit multiplication:**
   - Tokens are already separated correctly
   - Adjacent tokens without operators are parse errors

## TDD Approach

Follow same pattern as Phase 23:
- RED: Create comprehensive test file first
- GREEN: Implement parser to pass all tests
- REFACTOR: Clean up if needed
</context>

<tasks>
## RED Phase - Write Failing Tests

### Task 1: Create test file structure
Create `tests/test_expression_parser.py` with imports and test class structure.

### Task 2: Test ExprNode classes
- NumberNode, VariableNode, BinaryOpNode, UnaryOpNode, FracNode
- Test dataclass fields and equality

### Task 3: Test number parsing
- Integer: `5` → NumberNode(5.0)
- Decimal: `3.14` → NumberNode(3.14)
- Scientific: `1e6` → NumberNode(1000000.0)

### Task 4: Test variable parsing
- Simple: `x` → VariableNode("x")
- Subscript: `E_{26}` → VariableNode("E_{26}")
- Superscript: `R^2` → VariableNode("R^2")
- Greek: `\alpha` → VariableNode("\\alpha")

### Task 5: Test unit token handling
- Unit tokens pass through: UNIT("kg") → UnitNode("kg")
- Units after expression: `5 \text{kg}` → UnitAttachNode(NumberNode(5), "kg")

### Task 6: Test binary operators
- Addition: `a + b` → BinaryOpNode("+", a, b)
- Subtraction: `a - b` → BinaryOpNode("-", a, b)
- Multiplication: `a * b`, `a \cdot b`, `a \times b` → BinaryOpNode("*", a, b)
- Division: `a / b` → BinaryOpNode("/", a, b)
- Power: `a ^ b` → BinaryOpNode("^", a, b)

### Task 7: Test operator precedence
- `a + b * c` → BinaryOpNode("+", a, BinaryOpNode("*", b, c))
- `a * b + c` → BinaryOpNode("+", BinaryOpNode("*", a, b), c)
- `a ^ b ^ c` → BinaryOpNode("^", a, BinaryOpNode("^", b, c)) [right assoc]
- `a + b * c ^ d` → correct nesting

### Task 8: Test parentheses
- `(a + b) * c` → BinaryOpNode("*", BinaryOpNode("+", a, b), c)
- `\left( a \right)` → same as `(a)`
- Nested: `((a))` → a

### Task 9: Test fractions
- `\frac{a}{b}` → FracNode(a, b) or BinaryOpNode("/", a, b)
- `\frac{1}{2}` → FracNode(1, 2)
- Nested: `\frac{\frac{a}{b}}{c}` → correct structure

### Task 10: Test unary minus
- `-5` → UnaryOpNode("-", NumberNode(5))
- `-x` → UnaryOpNode("-", VariableNode("x"))
- `-(a + b)` → UnaryOpNode("-", BinaryOpNode(...))
- `a + -b` → BinaryOpNode("+", a, UnaryOpNode("-", b))

### Task 11: Test complex expressions
- `\frac{a + b}{c * d}` → correct tree
- `a ^ 2 + b ^ 2` → correct tree
- `\frac{1}{2} \cdot x` → correct tree

### Task 12: Test error handling
- Empty expression → ParseError
- Unclosed parenthesis → ParseError
- Missing operand: `a +` → ParseError
- Missing operator (implicit mult): `a b` → ParseError

### Task 13: Run tests - verify all fail
Run pytest, confirm tests fail with ImportError (module doesn't exist).
Commit: `test(24-01): add failing tests for expression parser`

## GREEN Phase - Implement Parser

### Task 14: Create expression_parser.py module
Create `src/livemathtex/parser/expression_parser.py` with:
- ExprNode base class
- NumberNode, VariableNode, BinaryOpNode, UnaryOpNode dataclasses
- FracNode dataclass
- UnitAttachNode dataclass (for unit attachment after value)

### Task 15: Implement ExpressionParser class
- Constructor: takes List[Token]
- `parse()` method: returns ExprNode
- Token position tracking and helper methods

### Task 16: Implement precedence levels
- `_expression()` → entry point, calls `_additive()`
- `_additive()` → handles +, -
- `_multiplicative()` → handles *, /, \cdot, \times
- `_power()` → handles ^ (right associative!)
- `_unary()` → handles unary -
- `_primary()` → handles atoms (numbers, variables, parens, fractions)

### Task 17: Implement fraction parsing
- `_parse_frac()` → handles `\frac{...}{...}`
- Uses brace matching from tokenizer
- Returns FracNode or BinaryOpNode("/", num, denom)

### Task 18: Implement error handling
- ParseError exception class
- Meaningful error messages with token position
- Graceful handling of unexpected EOF

### Task 19: Run tests - verify all pass
Run full test suite, confirm:
- All new parser tests pass
- All existing tests still pass
Commit: `feat(24-01): implement expression parser`

## REFACTOR Phase

### Task 20: Code review
- Check for code duplication
- Verify docstrings and comments
- Ensure consistent style with tokenizer

### Task 21: Create SUMMARY.md
Document what was built, decisions made, test results.
</tasks>

<verification>
## Verification Steps

1. Run new tests: `pytest tests/test_expression_parser.py -v`
2. Run full suite: `pytest tests/ -v`
3. Manual test with tokenizer integration:
   ```python
   from livemathtex.parser.expression_tokenizer import ExpressionTokenizer
   from livemathtex.parser.expression_parser import ExpressionParser

   tokens = ExpressionTokenizer(r"a + b \cdot c").tokenize()
   tree = ExpressionParser(tokens).parse()
   print(tree)  # Should show correct precedence
   ```
</verification>

<success_criteria>
- [ ] All ExprNode dataclasses defined with correct fields
- [ ] ExpressionParser handles all token types from Phase 23
- [ ] Operator precedence correct (PEMDAS)
- [ ] Right associativity for exponentiation
- [ ] Fraction parsing works (`\frac{a}{b}`)
- [ ] Unary minus handling
- [ ] Parentheses (regular and \left/\right)
- [ ] Error messages include position information
- [ ] All new tests pass
- [ ] All existing 410+ tests still pass
- [ ] TDD commits (RED, GREEN) made
</success_criteria>

<output>
## Expected Output

Files created:
- `src/livemathtex/parser/expression_parser.py` - Parser module
- `tests/test_expression_parser.py` - Comprehensive tests
- `.planning/phases/24-expression-parser/24-01-SUMMARY.md` - Execution summary

Commits:
1. `test(24-01): add failing tests for expression parser`
2. `feat(24-01): implement expression parser`
</output>

<notes>
## Implementation Notes

### Token handling
The parser consumes tokens from the tokenizer. Key patterns:
- `_current()` → peek at current token
- `_advance()` → consume and return current token
- `_check(type)` → check if current token is type
- `_match(*values)` → check and consume if matches

### Precedence via recursion
Each precedence level calls the next higher level:
```
_expression → _additive → _multiplicative → _power → _unary → _primary
     +,-          *,/,\cdot     ^              -        atoms
```

### Right associativity for ^
Power is right associative: `a^b^c = a^(b^c)`
```python
def _power(self):
    left = self._unary()
    if self._match('^'):
        right = self._power()  # Recursive call gives right assoc
        return BinaryOpNode('^', left, right)
    return left
```

### Unit attachment
After parsing a primary expression, check if next token is UNIT:
```python
def _primary(self):
    node = self._atom()
    if self._check(TokenType.UNIT):
        unit = self._advance().value
        return UnitAttachNode(node, unit)
    return node
```
</notes>
