# Phase 26 Plan 01: Evaluator Integration

<objective>
Integrate the new custom parser (Phases 23-25) into evaluator.py, creating a parallel evaluation path that uses the tokenizer→parser→evaluator pipeline instead of latex2sympy. This phase adds the new path alongside the existing one for testing and comparison.
</objective>

<execution_context>
@src/livemathtex/parser/expression_tokenizer.py - Tokenizer (Phase 23)
@src/livemathtex/parser/expression_parser.py - Parser (Phase 24)
@src/livemathtex/engine/expression_evaluator.py - Evaluator (Phase 25)
@src/livemathtex/engine/evaluator.py - Main evaluator to integrate with
@src/livemathtex/engine/pint_backend.py - Existing Pint functions
</execution_context>

<context>
## Background

Phases 23-25 created a complete custom parsing pipeline:
- ExpressionTokenizer: LaTeX → tokens
- ExpressionParser: tokens → ExprNode tree
- evaluate_expression_tree(): ExprNode → Pint Quantity

Now we need to integrate this into the main evaluator.py, specifically:
- `_compute_with_pint()` - currently uses latex2sympy
- `_compute()` - evaluation entry point

## Integration Strategy

**Parallel path approach:**
1. Add new method `_compute_with_custom_parser()` alongside existing `_compute_with_pint()`
2. Add feature flag to choose evaluation path
3. Test with existing test suite
4. Once all tests pass, make custom parser the default

## Key Files to Modify

- `src/livemathtex/engine/evaluator.py` - Add new evaluation path
- `src/livemathtex/engine/__init__.py` - Export new evaluator if needed

## TDD Approach

This phase focuses on integration, not new functionality. Use existing tests as validation - all 527+ tests must pass with the new parser.
</context>

<tasks>
## Task 1: Create integration wrapper

**Type:** auto

**Files:**
- `src/livemathtex/engine/evaluator.py`

**Action:**
Add a new method `_evaluate_with_custom_parser()` that:
1. Takes LaTeX expression string and symbol table
2. Tokenizes with ExpressionTokenizer
3. Parses with ExpressionParser
4. Evaluates with evaluate_expression_tree()
5. Returns Pint Quantity

Add imports at top of evaluator.py:
```python
from livemathtex.parser.expression_tokenizer import ExpressionTokenizer
from livemathtex.parser.expression_parser import ExpressionParser, ParseError
from livemathtex.engine.expression_evaluator import evaluate_expression_tree, EvaluationError
```

**Verify:**
- Method exists and is callable
- No import errors

**Done:**
- [ ] `_evaluate_with_custom_parser()` method added
- [ ] Imports added without errors

## Task 2: Route `==` evaluation through custom parser

**Type:** auto

**Files:**
- `src/livemathtex/engine/evaluator.py`

**Action:**
Modify `_compute_with_pint()` to try the custom parser first, falling back to latex2sympy on failure:

```python
def _compute_with_pint(self, expression_latex: str) -> 'pint.Quantity':
    # Try custom parser first
    try:
        return self._evaluate_with_custom_parser(expression_latex)
    except (ParseError, EvaluationError) as e:
        # Log for debugging, fall back to latex2sympy
        logger.debug(f"Custom parser failed, falling back: {e}")

    # Original latex2sympy path (kept as fallback)
    ...existing code...
```

**Important:** Keep the existing latex2sympy code intact as fallback. We want to compare results.

**Verify:**
- Run: `pytest tests/test_pint_evaluator.py -v`
- All tests should pass

**Done:**
- [ ] Custom parser tried first for `==` evaluations
- [ ] Fallback to latex2sympy works
- [ ] test_pint_evaluator.py passes

## Task 3: Run full test suite

**Type:** auto

**Files:**
- None (testing only)

**Action:**
Run the complete test suite to verify the integration doesn't break anything:

```bash
pytest tests/ -v --tb=short
```

Document any failures and their causes.

**Verify:**
- All 527+ tests pass (or same pass rate as before)
- Any failures are documented

**Done:**
- [ ] Full test suite run
- [ ] Pass rate same as before (527+ pass)
- [ ] Any failures documented

## Task 4: Test with real document

**Type:** auto

**Files:**
- None (testing only)

**Action:**
Test the integration with a real document to verify it works in practice:

```bash
# Process a real document
livemathtex process /home/mark/Repositories/mark-private/private/axabio_confidential/business/abp_2026_2030/docs/astaxanthin_production_analysis.md --dry-run
```

Compare output to ensure results are correct.

**Verify:**
- Document processes without errors
- Results match expected values

**Done:**
- [ ] Real document processed successfully
- [ ] Results verified as correct
</tasks>

<verification>
## Verification Steps

1. Run Pint evaluator tests: `pytest tests/test_pint_evaluator.py -v`
2. Run expression evaluator tests: `pytest tests/test_expression_evaluator.py -v`
3. Run full test suite: `pytest tests/ -v --tb=no`
4. Test real document processing
</verification>

<success_criteria>
- [ ] `_evaluate_with_custom_parser()` method implemented
- [ ] Custom parser integrated into `_compute_with_pint()`
- [ ] Fallback to latex2sympy works when custom parser fails
- [ ] All existing tests pass
- [ ] Real document processes correctly
</success_criteria>

<output>
## Expected Output

Files modified:
- `src/livemathtex/engine/evaluator.py` - Integration wrapper and routing

Commits:
1. `feat(26-01): integrate custom parser into evaluator`

Summary:
- `.planning/phases/26-evaluator-integration/26-01-SUMMARY.md`
</output>

<notes>
## Implementation Notes

### Symbol table format
The existing evaluator stores symbols in `self._pint_values` as a dict mapping symbol names to Pint Quantities. The custom evaluator expects the same format.

### Name normalization
The ExpressionTokenizer preserves LaTeX names (E_{26}, \alpha). The evaluator may need to normalize these for lookup. The expression_evaluator.py already handles this with `_lookup_variable()`.

### Error handling
ParseError from parser, EvaluationError from evaluator. Both should trigger fallback to latex2sympy.

### Debugging
Add logging to track which path is used:
```python
logger.debug(f"Using custom parser for: {expression_latex}")
```
</notes>
