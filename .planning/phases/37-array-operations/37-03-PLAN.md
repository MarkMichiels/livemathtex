# Plan 37-03: Evaluator Extension for Arrays

## Objective

Extend the expression evaluator to handle ArrayNode and IndexNode, enabling array creation and element access.

## Files to Modify

1. `src/livemathtex/engine/expression_evaluator.py`

## Changes

### 1. Import New Node Types

```python
from livemathtex.parser.expression_parser import (
    # ... existing imports ...
    ArrayNode,
    IndexNode,
)
```

### 2. Add Array Evaluation in `_eval_node`

```python
# ArrayNode: create list of evaluated values
if isinstance(node, ArrayNode):
    return [_eval_node(elem, symbols, ureg) for elem in node.elements]

# IndexNode: access array element
if isinstance(node, IndexNode):
    array_val = _eval_node(node.array, symbols, ureg)
    index_val = _eval_node(node.index, symbols, ureg)

    # Index must be an integer
    if isinstance(index_val, pint.Quantity):
        if not index_val.dimensionless:
            raise EvaluationError("Array index must be dimensionless")
        idx = int(index_val.magnitude)
    else:
        idx = int(index_val)

    if not isinstance(array_val, list):
        raise EvaluationError(f"Cannot index non-array value")

    if idx < 0 or idx >= len(array_val):
        raise EvaluationError(f"Array index {idx} out of bounds (0-{len(array_val)-1})")

    return array_val[idx]
```

### 3. Update Binary Operations for Broadcasting

Modify `_apply_binary_op` to handle array operands:

```python
def _apply_binary_op(op, left, right, ureg):
    # Handle array operations
    left_is_array = isinstance(left, list)
    right_is_array = isinstance(right, list)

    if left_is_array and right_is_array:
        # Element-wise operation
        if len(left) != len(right):
            raise EvaluationError(f"Array size mismatch: {len(left)} vs {len(right)}")
        return [_apply_binary_op(op, l, r, ureg) for l, r in zip(left, right)]

    if left_is_array:
        # Broadcast right to left
        return [_apply_binary_op(op, l, right, ureg) for l in left]

    if right_is_array:
        # Broadcast left to right
        return [_apply_binary_op(op, left, r, ureg) for r in right]

    # ... existing scalar operations ...
```

## Tests

Add tests in `tests/test_expression_evaluator_arrays.py`:

```python
def test_evaluate_array_literal():
    symbols = {}
    tree = parse("[1, 2, 3]")
    result = evaluate_expression_tree(tree, symbols)
    assert len(result) == 3
    assert result[0].magnitude == 1.0

def test_evaluate_index_access():
    ureg = get_unit_registry()
    symbols = {"arr": [1 * ureg.m, 2 * ureg.m, 3 * ureg.m]}
    tree = parse("arr[0]")
    result = evaluate_expression_tree(tree, symbols)
    assert result.magnitude == 1.0

def test_evaluate_scalar_times_array():
    tree = parse("2 * [1, 2, 3]")
    result = evaluate_expression_tree(tree, {})
    assert result[0].magnitude == 2.0
    assert result[1].magnitude == 4.0
```

## Verification

```bash
pytest tests/test_expression_evaluator_arrays.py -v
pytest tests/ -v  # All tests
```

## Estimated Time

45-60 minutes
