---
phase: 34-function-evaluation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/livemathtex/parser/expression_parser.py
  - src/livemathtex/engine/expression_evaluator.py
  - tests/test_iss_032_function_evaluation.md
autonomous: true
domain: parser
---

# Plan 34-01: Fix User-Defined Function Call Parsing and Evaluation

## Objective

**Goal:** Enable user-defined functions to be called with arguments (e.g., `PPE_{eff}(0.90)`).

**Purpose:** Currently, functions can be defined but not called. The parser throws "Unexpected token after expression: lparen" when encountering function calls.

**Output:** Functions defined with `f(x) := expression` can be evaluated with `f(0.5) ==`.

## Execution Context

@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

## Context

@.planning/PROJECT.md
@.planning/STATE.md
@src/livemathtex/parser/expression_parser.py
@src/livemathtex/engine/expression_evaluator.py

## Tasks

<task id="1" type="auto">
  <name>Add FunctionCallNode to expression parser</name>
  <files>
    - src/livemathtex/parser/expression_parser.py
  </files>
  <action>
    1. Add FunctionCallNode class after FuncNode:
       ```python
       @dataclass
       class FunctionCallNode(ExprNode):
           """User-defined function call (f(x), PPE_{eff}(0.90), etc.)."""
           name: str  # Function name
           args: List[ExprNode]  # Arguments
       ```

    2. Update _primary() method to detect function calls:
       - After parsing a VariableNode, check if next token is LPAREN
       - If so, parse as function call: parse arguments, expect RPAREN
       - Return FunctionCallNode instead of VariableNode

    3. Handle multi-argument functions: parse comma-separated arguments
  </action>
  <verify>
    - ExpressionParser can parse `f(0.5)` as FunctionCallNode
    - ExpressionParser can parse `PPE_{eff}(0.90)` as FunctionCallNode
    - Existing variable parsing still works
  </verify>
  <done>
    - FunctionCallNode class exists
    - Parser creates FunctionCallNode for function calls
    - Tests pass: variable parsing, function call parsing
  </done>
</task>

<task id="2" type="auto">
  <name>Handle FunctionCallNode in expression evaluator</name>
  <files>
    - src/livemathtex/engine/expression_evaluator.py
  </files>
  <action>
    1. Import FunctionCallNode from expression_parser

    2. Add handler in _eval_node() for FunctionCallNode:
       ```python
       if isinstance(node, FunctionCallNode):
           return _eval_function_call(node, symbols, ureg)
       ```

    3. Implement _eval_function_call():
       - Look up function in symbols by name (try normalized variants)
       - Get function's formula_expression and parameters
       - Evaluate argument expressions
       - Substitute parameter values in formula
       - Evaluate substituted formula

    4. Handle errors:
       - Function not found → EvaluationError
       - Wrong number of arguments → EvaluationError
       - Evaluation failure → EvaluationError with context
  </action>
  <verify>
    - _eval_function_call handles single-argument functions
    - Error messages are clear for undefined functions
    - Argument evaluation works correctly
  </verify>
  <done>
    - FunctionCallNode handled in _eval_node
    - _eval_function_call implemented
    - Error handling complete
  </done>
</task>

<task id="3" type="auto">
  <name>Verify function evaluation works end-to-end</name>
  <files>
    - tests/test_iss_032_function_evaluation.md
  </files>
  <action>
    1. Clear and process test file:
       ```bash
       livemathtex clear tests/test_iss_032_function_evaluation.md
       livemathtex process tests/test_iss_032_function_evaluation.md
       ```

    2. Verify output shows calculated value instead of error

    3. Run full test suite to ensure no regressions:
       ```bash
       python -m pytest tests/ -v --tb=short
       ```
  </action>
  <verify>
    - test_iss_032_function_evaluation.md processes without errors
    - PPE_{result} shows calculated value (~3.765)
    - All existing tests still pass
  </verify>
  <done>
    - Test file shows correct calculation
    - No regression in test suite
    - ISS-047 resolved
  </done>
</task>

## Verification

After all tasks:
1. Clear and process test_iss_032_function_evaluation.md - should show `PPE_{result} = ~3.765`
2. Run pytest - all tests pass
3. Check no new errors in other ISS test files

## Success Criteria

- [ ] FunctionCallNode class added to expression_parser.py
- [ ] Parser correctly parses function calls like `f(0.5)` and `PPE_{eff}(0.90)`
- [ ] Expression evaluator handles FunctionCallNode
- [ ] Function call evaluation substitutes arguments and evaluates formula
- [ ] test_iss_032_function_evaluation.md produces correct output
- [ ] All existing tests pass (no regressions)
- [ ] ISS-047 closed

## Output

- **Commit message template:**
  ```
  fix(parser): support user-defined function calls (ISS-047)

  - Add FunctionCallNode to expression parser
  - Handle function calls in expression evaluator
  - Substitute parameters and evaluate formula
  - Closes ISS-047
  ```

- **SUMMARY.md** created after execution
