---
phase: 08-markdown-parser-integration
plan: 01
type: execute
---

<objective>
Integrate hybrid parser: markdown-it-py for document structure + pylatexenc for character-level LaTeX parsing.

Purpose: Replace fragile regex-based parsing with robust two-layer approach that properly handles code fences and provides character-level position tracking within math blocks.
Output: New `parser/markdown_parser.py` module with hybrid parsing pipeline.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-markdown-parser-integration/08-RESEARCH.md

**Key files:**
@src/livemathtex/parser/lexer.py
@src/livemathtex/parser/models.py

**Research findings (hybrid approach):**
- Layer 1: markdown-it-py + dollarmath_plugin → math block boundaries
- Layer 2: pylatexenc LatexWalker → character-level positions within LaTeX
- Combine: `document_offset + latex_node.pos` = absolute position

**Dependencies:**
- `markdown-it-py>=3.0.0`
- `mdit-py-plugins>=0.4.0`
- `pylatexenc>=2.10`

**Constraints:**
- Don't break existing API (`process_text`, `clear_text`)
- Use `tolerant_parsing=True` for malformed LaTeX
- Normalize `\r\n` to `\n` before parsing
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies for hybrid parser</name>
  <files>pyproject.toml</files>
  <action>
Add dependencies to pyproject.toml:
- `markdown-it-py>=3.0.0`
- `mdit-py-plugins>=0.4.0`
- `pylatexenc>=2.10`

Run `pip install -e .` to install new dependencies and verify imports work.
  </action>
  <verify>python -c "from markdown_it import MarkdownIt; from mdit_py_plugins.dollarmath import dollarmath_plugin; from pylatexenc.latexwalker import LatexWalker; print('OK')"</verify>
  <done>All three libraries installed and importable</done>
</task>

<task type="auto">
  <name>Task 2: Create markdown_parser.py with hybrid pipeline</name>
  <files>src/livemathtex/parser/markdown_parser.py</files>
  <action>
Create new module `parser/markdown_parser.py` implementing the hybrid approach:

**1. MarkdownParser class:**
```python
class MarkdownParser:
    """Two-layer parser: markdown-it-py + pylatexenc"""

    def __init__(self):
        self.md = MarkdownIt().use(dollarmath_plugin, allow_space=True, allow_digits=True)

    def parse(self, text: str) -> List[Token]:
        """Parse markdown and return token stream."""
        # Normalize line endings
        text = text.replace('\r\n', '\n')
        return self.md.parse(text)
```

**2. Position conversion functions:**
```python
def build_line_offset_map(text: str) -> List[int]:
    """Build cumulative character offsets for each line start."""
    offsets = [0]
    for i, char in enumerate(text):
        if char == '\n':
            offsets.append(i + 1)
    return offsets

def line_to_char_offset(line: int, line_offsets: List[int]) -> int:
    """Convert 0-indexed line number to character offset."""
    if line < len(line_offsets):
        return line_offsets[line]
    return line_offsets[-1] if line_offsets else 0
```

**3. LaTeX parsing with pylatexenc:**
```python
def parse_latex_content(latex: str) -> List[LatexNode]:
    """Parse LaTeX string and return nodes with positions."""
    walker = LatexWalker(latex, tolerant_parsing=True)
    nodes, _, _ = walker.get_latex_nodes()
    return nodes if nodes else []

@dataclass
class LaTeXPosition:
    """Position of a LaTeX element within a math block."""
    pos: int           # Start position within LaTeX content
    pos_end: int       # End position within LaTeX content
    node_type: str     # 'chars', 'macro', 'group', etc.
    content: str       # The actual content
```

**4. Unified extraction:**
```python
@dataclass
class ParsedMathBlock:
    """Math block with document and LaTeX-level positions."""
    content: str              # Full content including $$
    inner_content: str        # Content without delimiters
    is_display: bool
    doc_start_offset: int     # Character offset in document
    doc_end_offset: int       # End offset in document
    start_line: int           # 0-indexed line number
    end_line: int
    latex_nodes: List[Any]    # pylatexenc nodes with positions

def extract_math_blocks(text: str) -> List[ParsedMathBlock]:
    """Extract all math blocks with full position information."""
    # 1. Normalize and parse with markdown-it-py
    # 2. Build line offset map
    # 3. For each math_block/math_inline token:
    #    - Calculate document offsets
    #    - Parse LaTeX content with pylatexenc
    #    - Combine positions
    # 4. Return list of ParsedMathBlock
```

Key implementation notes:
- Token.map gives [start_line, end_line) - end is exclusive
- Add delimiter length (2 for $$) when calculating content offset
- pylatexenc node.pos is relative to the LaTeX string, not document
- Use `tolerant_parsing=True` to handle incomplete/malformed LaTeX
  </action>
  <verify>
python -c "
from livemathtex.parser.markdown_parser import extract_math_blocks
text = '''# Test
\$\$
x := 5
\$\$
'''
blocks = extract_math_blocks(text)
print(f'Found {len(blocks)} blocks')
assert len(blocks) == 1
b = blocks[0]
assert b.is_display == True
assert b.latex_nodes is not None
print(f'LaTeX nodes: {len(b.latex_nodes)}')
print('OK')
"
  </verify>
  <done>MarkdownParser class with hybrid pipeline, extract_math_blocks returns ParsedMathBlock with both document offsets and LaTeX nodes</done>
</task>

<task type="auto">
  <name>Task 3: Add comprehensive tests for hybrid parser</name>
  <files>tests/test_markdown_parser.py</files>
  <action>
Create comprehensive tests for the hybrid parser:

**1. Markdown-level tests:**
- Single inline `$x$` and display `$$x$$`
- Multiple math blocks in document
- Code fences containing `$$` (should NOT be extracted)
- Math after code blocks (should be extracted)

**2. Position accuracy tests:**
- Verify `text[doc_start:doc_end]` includes delimiters
- Verify inner_content matches content without delimiters
- Test multiline math blocks
- Test math at document start and end

**3. LaTeX parsing tests:**
- Verify pylatexenc nodes are populated
- Test simple expressions: `x := 5`
- Test macros: `\frac{a}{b}`, `\text{kg}`
- Test malformed LaTeX (should not crash with tolerant_parsing)

**4. Position combination tests:**
- Find `:=` operator in `$$x := 5$$` - verify absolute position
- Verify `text[doc_start + latex_pos : doc_start + latex_pos_end]` works

**5. Edge cases:**
- Empty math blocks `$$$$`
- Dollar signs in regular text
- Nested braces in LaTeX

Use pytest fixtures for common test documents.
  </action>
  <verify>cd /home/mark/Repositories/livemathtex && python -m pytest tests/test_markdown_parser.py -v</verify>
  <done>All tests pass, hybrid parsing verified for both layers</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `pip install -e .` succeeds with all three dependencies
- [ ] `python -c "from livemathtex.parser.markdown_parser import MarkdownParser, extract_math_blocks"` works
- [ ] `python -m pytest tests/test_markdown_parser.py -v` all pass
- [ ] Document-level positions verified: `text[start:end] == content`
- [ ] LaTeX-level positions verified: pylatexenc nodes have correct pos/pos_end
- [ ] Code fences properly excluded from math parsing
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Hybrid pipeline extracts both:
  - Document-level positions (character offsets)
  - LaTeX-level positions (node positions within math content)
- Code fences properly excluded
- Malformed LaTeX handled gracefully (tolerant_parsing)
</success_criteria>

<output>
After completion, create `.planning/phases/08-markdown-parser-integration/08-01-SUMMARY.md`
</output>
